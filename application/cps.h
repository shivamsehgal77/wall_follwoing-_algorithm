#ifndef __CPS_H__
#define __CPS_H__

/**
 * @file cps.h
 * @author Chris/Patrik/Shivam (you@domain.com)
 * @brief .h file for RWA2
 * @version 0.1
 * @date 2022-11-04
 * 
 * @copyright Copyright (c) 2022
 * 
 */

#pragma once
#include <utility>
#include <iostream>
#include <array>
#include "simulator/simulator.h"
#include <memory>
#include <stdlib.h>
#include <vector>



namespace rwa2group2 {
 /**
  * @brief 
  * 
  */
    
 class Robot {
   public:
     Robot(){
        m_position={0,0};
        m_direction='n'; 
        }
    
    /**
     * @brief Get the position x object
     * 
     * @return int 
     */  
     int get_position_x();
    /**
     * @brief Get the position y object
     * 
     * @return int 
     */
     int get_position_y();
    /**
     * @brief Get the direction object
     * 
     * @return char 
     */
     char get_direction();
    /**
     * @brief Turns the robot left
     * 
     */
  
     void turn_left();
    /**
     * @brief Turns the robot right
     * 
     * 
     */
 
     void turn_right();
    /**
     * @brief Moves the robot forward
     * 
     */
   
     void move_forward();

    /**
     * @brief Store the current position of the robot in std::pair where first is x distance and second is y diatance
     * 
     */
     std::pair<int, int> m_position;
     /**
      * @brief Store the current position of the robot.(North "n",South "s",East "e", West "w")
      * 
      */
     char m_direction;

};

/**
* @brief This class represents a cell in the maze
*/
 class Cell {
    
    
  public:
// initialize all 4 walls of a cell
/**
 * @brief Intialize all the four walls of the cells as false or no walls
 * 
 */
    void init_cell_walls();
/**
 * @brief Set the all the four walls for the curent cell using is_wall
 * 
 * @param m_position 
 */
   void set_wall(std::pair<int ,int> m_position);
/**
 * @brief Checks if wall present and sets m_walls to ture based on it
 * 
 * @param wall 
 */

   void is_wall(char wall);
// private:
//!<@brief The walls of the cell.
//!< true means the wall is open
//!< false means the wall is closed
//!< 0 = North, 1 = East, 2 = South, 3 = West
    /**
     * @brief Array that stores the walls for the cell as true or false
     * 
     */
    std::array<bool, 4> m_walls;
    /**
     * @brief  Array of directions
     * 
     */
    std::array<char,4> directions{'n', 'e', 's', 'w'};
};

 class Algorithm {
  public:
    Algorithm(int height, int width):
        m_maze_height{height},
        m_maze_width{width}{
        robot=std::make_unique<Robot>();
        path;
        best_path;
    }
    /**
     * @brief Colors the outer walls
     * 
     */
     void init_outer_walls();

    /**
     * @brief Makes the robot follow left wall
     * 
     */
     void follow_wall_left();


    /**
     * @brief Makes the robot follow right wall
     * 
     */
     void follow_wall_right();

    /**
     * @brief  Generates a random goal in the outer cells
     * 
     * @return std::pair<int,int> 
     */
     std::pair<int,int> generate_goal();
    /**
     * @brief Generates the best path for the robot
     * 
     * @param path 
     */
     void generate_best_path(std::vector<std::pair<int,int>> &path);
    /**
     * @brief Returns the robot to home position
     * 
     * @param path 
     */
     void go_home(std::vector<std::pair<int,int>> &path);

    /**
     * @brief Store Cell as arrays
     * 
     */
//!<@brief A maze is a 2D array of cells.
   std::array<std::array<Cell, 16>, 16> m_maze;
    /**
     * @brief A pointer variable to robot class
     * 
     */
   std::unique_ptr<Robot> robot;
    /**
     * @brief Store the goal
     * 
     */
   std::pair<int, int> goal;
    /**
     * @brief path vector stores the path the robot follows to reach the goal
     * 
     */
   std::vector<std::pair<int,int>> path;
    /**
     * @brief  best_path stores the best path as generated by the best_path function.
     * 
     */
   std::vector<std::pair<int,int>> best_path;
    /**
     * @brief  stores the maze width
     * 
     */
     int m_maze_width;
    /**
     * @brief stores the maze height
     * 
     */
     int m_maze_height;




};
}

#endif
